####  1. Define transformed operations
source("C:/Linear_Prediction/2_TransformedOperations.R")

####  2. Illustration for tail ratio in subset V_+^q
source("C:/Linear_Prediction/3_TailRatio.R")
##  A matrix 'A' for illustration
##  Reproduce Figure 2
set.seed(334)
A <- matrix( c(1, 1, -10, -1), ncol = 2)
TailRatioPlot(n = 10000, Ncol = 2, A = A)

####  3. Calculate the tail ratio of prediction error
source("C:/Linear_Prediction/4_PredictionError.R")
##  Set a seed number to reproduce Figure 3
set.seed(1205)
PredictionError(Ncol = 10, Nrow = 4, n = 20000, min = 0, max = 5, plot_D=T)
##  Arguments
##  Ncol, Nrow: the dimension of a matrix 'A'
##  n: the number of samples
##  min, max: the range of a uniform dist
##  plot_D: logical returning a scatterplot of 'D' against 'Xhat'

##  Value
##  PredictionError returns a list with the tail ratio of prediction error 'kstar' from a known A
##  , the optimized vector 'b', a vector of D 'D_TPDM', assessed coverage rate 'Coverate_D', a scatterplot of D against Xhat

####  4. Simulate a vector X generated by a higher dimensional matrix A
source("C:/Linear_Prediction/5_TPDM_Ang.R")
##  Set a seed number to reproduce Figure 4
set.seed(1234)
Out=TPDM_Ang(Ncol = 400,Nrow = 7,n = 60000,min = 0,max = 5)
##  Argument
##  Ncol, Nrow: the dimension of a matrix A
##  n: the number of samples
##  min, max: the range of a uniform distribution

##  Value
##  TPDM_Ang returns a list with a data matrix 'X_t', a vector of predicted values 'Xhat', a vector b, A_Pred, TPMD_Pred, TR, known Ang_T & Ang_mass

####  5. Estimate the TPDM and obtain the 'Prediction' inner product matrix (IPM)
library(MASS) # need this package for the 'solve' function
source("C:/Linear_Prediction/6_TPDM_Est.R")
TPDM_Out=TPDM_Est(Nrow = 7, Thres=0.99, X_t = Out$X_t[1:40000,])
##  Input: dimension of X, threshold, the 2/3 random realizations of X in a training set
##  Output: estimated TPDM, prediction IPM, optimized vector b
TPDM_Out$TPDM_hat
TPDM_Out$TPDM_P_hat
TPDM_Out$bhat

####  6. Completely positive decomposition for a 2x2 prediction IPM
source("C:/Linear_Prediction/7_Ang_CPD.R")
AngCPD_Out=Ang_CPD(TPDM_P_hat = TPDM_Out$TPDM_P_hat) # Use the prediction IPM
#AngCPD_Out=Ang_CPD(TPDM_P_hat = Out$TPDM_Pred) # Use the true prediction IPM (for comparison)
##  Input: TPDM_P_hat(a 2x2 prediction IPM)
##  Output: Multiple angles and angular masses via CPD

##  Save the output based on the estimated prediction IPM
save(AngCPD_Out,file="C:/Linear_Prediction/AngCPD_Out_P.Rdata")
load(file="C:/Linear_Prediction/AngCPD_Out_P.Rdata")

####  Create the 95% joint polar region by decomposing the prediction IPM iteratively
library(plotrix)  # Need this package for a function 'draw.circle'
source("C:/Linear_Prediction/8_JointRegion.R")
##  Calculate Xhats in the test set
Xhat_t=Amul(t(TPDM_Out$bhat),t(Out$X_t[40001:60000,1:6]))
Xhat_t=as.vector(Xhat_t)
##  Find the 95% joint polar region (Reproducing Figure 4 (left))
Out2=JointRegion(X_f = Out$X_t[-(1:40000),7], Xhat = Xhat_t
                 , Ang = AngCPD_Out$All_ang, Ang_mass = AngCPD_Out$All_mass
                 , tol=0.001, plot = T, ray = FALSE, cone=T, xr1 = 0, xr2 = 110, yr1 = 0, yr2 = 110, Plot_Point = T)
##  Input: X_f(Predictant), Xhat(Prediction), Angular components, Angular masses, tol(Tolerance for difference between interpolated values and empirical quantiles)
##  Output: Ang_ecdf (empirical cdf), Mtx_P=cbind(Xhat,X_f), Total mass, Lower bound, Upper bound, Coverage rate
##  the rest arguments are for graphical components.

####  Assess the variability of quantiles for joint polar regions


####  Kernel density estimation for a joint angular density 'h'
library(VGAM)
library(ks)
source("C:/Linear_Prediction/9_Ang_kde.R")
##  A kernel angular density with angular components and masses via CPD
kde_cpd_out=Ang_kde(Ang_T = AngCPD_Out$All_ang, Ang_mass = AngCPD_Out$All_mass,bw = T,h = 0.3 ,plot_theta = T, plot_w = T,y_lim = 3)
##  Inputs: Angles obtained by CPD, Angular masses obtained by CPD, bandwidth
##  Outputs: kde w.r.t angles, kde w.r.t angular components (w)

##  A kernel angular density with known angular components and masses (for comparison)
#kde_out=Ang_kde(Ang_T = Out$Ang_T,Ang_mass = Out$Ang_mass,bw = T,h = 0.3 ,plot_theta = T, plot_w = T,y_lim = 3)

####  Find an approximate conditional density through CPD
##  Cond_coverage returns a list with lower bound 'Con_L' and upper bound 'Con_U' and a binary value 1 if the conditional density contains predictand 0 otherwise
source("C:/Linear_Prediction/10_CondDens.R")
a=2
CondDen_Out=CondDens(z = Out2$Mtx_P[a,], h_w2_CPD = kde_cpd_out$kde_trans_w, plot = T)
Out2$Mtx_P[a,]
##  Inputs: cbind(X_predictant, Xhat), kde via CPD
##  Outputs: X_(p+1), conditional density, CDF / X_(p+1), conditional density via CPD, CDF via CPD

####  Coverage rate for the conditional intervals
source("C:/Linear_Prediction/11_CondInterval.R")
Pred_inter=CondInterval(z2 = CondDen_Out$z2_CPD, X_f_single = Out2$Mtx_P[a,2], cumTraps = CondDen_Out$cumTraps, tol = 0.0001)
##  Value

####  Plot an approximate conditional density with a 95% conditional interval
source("C:/Linear_Prediction/12_CondDenPlot.R")
##  Conditional density via CPD
##  Reproduce Figure 4 (center)
CondDenPlot(a = c(15171),X_f = Out2$Mtx_P[,2],Xhat = Out2$Mtx_P[,1], Ang = AngCPD_Out$All_ang, Ang_mass = AngCPD_Out$All_mass
              , h_w2_CPD = kde_cpd_out$kde_trans_w, tol = 0.0001
              , ConDen_CPD = T, Cond_Int_CPD = T, xr1 = 33.15, xr2 = 33.21, yr1 = 0, yr2 = 90)

####  Assess the coverage rate
source("C:/Linear_Prediction/13_AssessCoverage.R")
Out3=AssessCoverage(Mtx_P = Out2$Mtx_P, Thres = 0.95, h_w2_CPD = kde_cpd_out$kde_trans_w, Thres_Xhat = T, Thres_rad = FALSE)
Out3$CoverageRate  
#0.947 when the 0.95 quantile is used

####  Plot conditional intervals for the largest 5% given Xhat is large
source("C:/Linear_Prediction/14_CondIntervalPlot.R")
PredIntervals=CondIntervalPlot(Mtx_P = Out2$Mtx_P, Thres = 0.95, h_w2_CPD = kde_cpd_out$kde_trans_w)
PredIntTop5=PredIntervals$CondIntervalSave
colnames(PredIntTop5)=c("LB","UB","Xhat","X_f")
##  Argument
##  Mtx_P: a test set

####  Save 95% conditional intervals for the largest 5%
save(PredIntTop5,file="C:/Linear_Prediction/PredIntTop5.Rdata")
load(file="C:/Linear_Prediction/PredIntTop5.Rdata")

####  Plot conditional intervals with lines to reproduce Figure 4 (right)
dev.new()
par(mar=c(5.1,5.1,2,2))
sl <- sort.list(PredIntTop5[,3])
PredIntSort=PredIntTop5[sl,]
plot(PredIntTop5[,3],PredIntTop5[,4],xlim=c(0,50),ylim=c(0,50),main="",xlab="",ylab="Observed values", cex.main=1.5, cex.lab=1.5, cex.axis=1.5,cex=1.3)
title(xlab=expression(hat(X)[p+1]),line=3.5, cex.lab=1.5)
#title(xlab="Predicted values",line=3.5, cex.lab=1.5)
lines(PredIntSort[,3],PredIntSort[,1], lty = 2, cex=2, lwd=2, col="blue")
lines(PredIntSort[,3],PredIntSort[,2], lty = 2, cex=2, lwd=2, col="blue")
